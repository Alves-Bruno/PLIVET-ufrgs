"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Java8Engine = void 0;
const agh = require("agh.sprintf");
const UniBinOp_1 = require("../../node/UniBinOp");
const UniClassDec_1 = require("../../node/UniClassDec");
const UniExpr_1 = require("../../node/UniExpr");
const UniIdent_1 = require("../../node/UniIdent");
const UniMethodCall_1 = require("../../node/UniMethodCall");
const UniNew_1 = require("../../node/UniNew");
const UniNewArray_1 = require("../../node/UniNewArray");
const UniStringLiteral_1 = require("../../node/UniStringLiteral");
const UniUnaryOp_1 = require("../../node/UniUnaryOp");
const Engine_1 = require("../Engine/Engine");
class Java8Engine extends Engine_1.Engine {
    // Byte[]
    static strToBytes(str) {
        const length = str.length;
        const bytes = [];
        for (let i = 0; i < length; ++i) {
            const code = str.charCodeAt(i);
            bytes.push(code);
        }
        bytes.push(0);
        return bytes;
    }
    static getCharArrAsByte(objectOnMemory, beginArg) {
        let begin = beginArg;
        const bytes = [];
        const obj = objectOnMemory.get(begin);
        if (typeof obj === 'string') {
            return Java8Engine.strToBytes(obj);
        }
        for (let v = obj; objectOnMemory.containsKey(begin); ++begin) {
            const o = objectOnMemory.get(begin);
            if (typeof obj === 'number') {
                v = o;
                if (v === 0) {
                    break;
                }
                bytes.push(v);
            }
            else {
                break;
            }
        }
        bytes.push(0);
        return bytes;
    }
    static charArrToStr(objectOnMemory, beginArg) {
        const bytes = this.getCharArrAsByte(objectOnMemory, beginArg);
        return Engine_1.Engine.bytesToStr(bytes);
    }
    constructor() {
        super();
    }
    *execUnaryOp(uniOp, scope) {
        if (uniOp.operator === '++' || uniOp.operator === '--') {
            uniOp.operator = uniOp.operator + '_';
        }
        switch (uniOp.operator) {
            case '&': {
                const adr = yield* this.getAddress(uniOp.expr, scope);
                return adr;
            }
            case '*': {
                const v = scope.getValue((yield* this.execExpr(uniOp.expr, scope)));
                return v;
            }
            case 'sizeof': {
                const l = [];
                if (uniOp.expr instanceof UniIdent_1.UniIdent) {
                    l.push(new UniStringLiteral_1.UniStringLiteral(uniOp.expr.name));
                }
                else {
                    l.push(uniOp.expr);
                }
                const umc = new UniMethodCall_1.UniMethodCall(null, new UniIdent_1.UniIdent('sizeof'), l);
                const v = yield* this.execExpr(umc, scope);
                return v;
            }
        }
        return yield* super.execUnaryOp(uniOp, scope);
    }
    sizeof(type) {
        return 1;
        /*		if(type.contains("char")){
                return 1;
            }
            else if(type.contains("short")){
                return 2;
            }
            else if(type.contains("double")){
                return 8;
            }
            return 4;*/
    }
    loadLibarary(global) {
        this.importJavaLang(global);
        this.importJavaUtil(global);
        // this.includeMath(global);
    }
    importJavaLang(global) {
        global.setTop('java', {
            lang: {
                Object: new UniClassDec_1.UniClassDec('Object', [], [], [], []),
            },
        }, 'CLASS');
        global.setTop('System', {
            out: {
                printf() {
                    if (arguments.length < 1) {
                        return 0;
                    }
                    const args = [];
                    for (const argument of arguments) {
                        args.push(argument);
                    }
                    let text = Engine_1.Engine.bytesToStr(args[0]);
                    text = text.replace('\\n', '\n');
                    for (let i = 1; i < args.length; ++i) {
                        if (global.typeOnMemory.containsKey(args[i])) {
                            const type = global.typeOnMemory.get(args[i]);
                            if (type.includes('char')) {
                                args[i] = Java8Engine.charArrToStr(global.objectOnMemory, args[i]);
                            }
                        }
                    }
                    args[0] = text;
                    const output = agh.sprintf(...args).replace('\\n', '\n');
                    this.stdout(output);
                    const byteCount = (str) => encodeURIComponent(str).replace(/%../g, 'x').length;
                    const count = byteCount(output);
                    return count;
                },
                println(arg) {
                    const text = Array.isArray(arg) ? Engine_1.Engine.bytesToStr(arg) : arg;
                    const output = agh.sprintf(String(text)).replace('\\n', '\n');
                    this.stdout(output + '\n');
                },
            },
        }, 'CLASS');
    }
    importJavaUtil(global) {
        global.setTop('java', {
            util: {
                Scanner: {
                    *nextInt() {
                        ////////////////////////////////////////////
                        const isStdinEmpty = this.getStdin() === '';
                        if (isStdinEmpty) {
                            this.setIsWaitingForStdin(true); // yield and set stdin
                            yield; // get args from next(args) from execUniMethodCall
                        }
                        ////////////////////////////////////////////
                        let input = this.getStdin();
                        this.clearStdin();
                        if (isStdinEmpty) {
                            this.stdout(input + '\n');
                        }
                        const start = Math.min(...Array.from(Array(10).keys())
                            .map((n) => input.indexOf(`${n}`))
                            .filter((pos) => pos !== -1));
                        const end = Math.min(...[' ', '\n', '\t']
                            .map((s) => input.indexOf(`${s}`, start))
                            .filter((pos) => pos !== -1));
                        if (0 <= end) {
                            this.stdin(input.substr(end));
                            input = input.substring(start, end);
                        }
                        if (isStdinEmpty) {
                            this.setIsWaitingForStdin(false);
                        }
                        return parseInt(input.trim(), 10);
                    },
                },
            },
        }, 'CLASS');
    }
    includeMath(global) {
        global.setTop('acos', (x) => {
            return Math.acos(x);
        }, 'FUNCTION');
        global.setTop('asin', (x) => {
            return Math.asin(x);
        }, 'FUNCTION');
        global.setTop('atan', (x) => {
            return Math.atan(x);
        }, 'FUNCTION');
        global.setTop('cos', (x) => {
            return Math.cos(x);
        }, 'FUNCTION');
        global.setTop('sin', (x) => {
            return Math.sin(x);
        }, 'FUNCTION');
        global.setTop('tan', (x) => {
            return Math.tan(x);
        }, 'FUNCTION');
        global.setTop('cosh', (x) => {
            return Math.cosh(x);
        }, 'FUNCTION');
        global.setTop('sinh', (x) => {
            return Math.sinh(x);
        }, 'FUNCTION');
        global.setTop('tanh', (x) => {
            return Math.tanh(x);
        }, 'FUNCTION');
        global.setTop('exp', (x) => {
            return Math.exp(x);
        }, 'FUNCTION');
        global.setTop('exp2', (x) => {
            return Math.pow(2.0, x);
        }, 'FUNCTION');
        global.setTop('expm1', (x) => {
            return Math.expm1(x);
        }, 'FUNCTION');
        global.setTop('log', (x) => {
            return Math.log(x);
        }, 'FUNCTION');
        global.setTop('log10', (x) => {
            return Math.log10(x);
        }, 'FUNCTION');
        global.setTop('log1p', (x) => {
            return Math.log1p(x);
        }, 'FUNCTION');
        global.setTop('cbrt', (x) => {
            return Math.cbrt(x);
        }, 'FUNCTION');
        global.setTop('fabs', (x) => {
            return Math.abs(x);
        }, 'FUNCTION');
        global.setTop('hypot', (x, y) => {
            return Math.hypot(x, y);
        }, 'FUNCTION');
        global.setTop('pow', (x, y) => {
            return Math.pow(x, y);
        }, 'FUNCTION');
        global.setTop('sqrt', (x) => {
            return Math.sqrt(x);
        }, 'FUNCTION');
        global.setTop('ceil', (x) => {
            return Math.ceil(x);
        }, 'FUNCTION');
        global.setTop('floor', (x) => {
            return Math.floor(x);
        }, 'FUNCTION');
        global.setTop('rint', (x) => {
            throw new Error('Sorry! rint is not supported.');
        }, 'FUNCTION');
        global.setTop('round', (x) => {
            return Math.round(x);
        }, 'FUNCTION');
        global.setTop('fdim', (x, y) => {
            const a = Math.abs(x);
            const b = Math.abs(y);
            return Math.abs(Math.max(a, b) - Math.min(a, b));
        }, 'FUNCTION');
        global.setTop('fmax', (x, y) => {
            return Math.max(x, y);
        }, 'FUNCTION');
        global.setTop('fmin', (x, y) => {
            return Math.min(x, y);
        }, 'FUNCTION');
        global.setTop('fmod', (x, y) => {
            const div = x / y;
            const n = 0 < div ? Math.floor(div) : Math.ceil(div);
            return x - y * n;
        }, 'FUNCTION');
    }
    *_execExpr(expr, scope) {
        if (expr instanceof UniNewArray_1.UniNewArray) {
            const ret = yield* this.execNewArray(expr, scope);
            yield ret;
            return ret;
        }
        else if (expr instanceof UniNew_1.UniNew) {
            const ret = yield* this.execNew(expr, scope);
            yield ret;
            return ret;
        }
        return yield* super._execExpr(expr, scope);
    }
    *execBinOp(arg, scope, left, right) {
        if (arg instanceof UniBinOp_1.UniBinOp && left === undefined && right === undefined) {
            const binOp = arg;
            return yield* this.execBinOp(binOp.operator, scope, binOp.left, binOp.right);
        }
        else if (typeof arg === 'string' && left instanceof UniExpr_1.UniExpr) {
            let op = arg;
            if (op === '++' || op === '--') {
                op = '_' + op;
                return yield* this.execUnaryOp(new UniUnaryOp_1.UniUnaryOp(op, left), scope);
            }
            if (right instanceof UniExpr_1.UniExpr) {
                return yield* super.execBinOp(op, scope, left, right);
            }
        }
    }
    execBinOpImple(op, l, r) {
        let isString = false;
        if (Array.isArray(l) && l[l.length - 1] === 0) {
            l = Engine_1.Engine.bytesToStr(l);
            isString = true;
        }
        if (Array.isArray(r) && r[r.length - 1] === 0) {
            r = Engine_1.Engine.bytesToStr(r);
            isString = true;
        }
        let ret = super.execBinOpImple(op, l, r);
        if (isString) {
            ret = Java8Engine.strToBytes(ret);
        }
        return ret;
    }
    *execVariableDec(decVar, scope) {
        let value = null;
        for (const def of decVar.variables) {
            // 初期化されている場合
            if (def.value != null) {
                // 配列の初期化もここでexecNewExprで行われる。
                value = yield* this.execExpr(def.value, scope);
                value = this._execCast(decVar.type, value);
                if (decVar.type.includes('[')) {
                    const end = decVar.type.indexOf('[');
                    decVar.type = decVar.type.substring(0, end);
                }
            }
            scope.setTop(def.name, value, decVar.type);
        }
        return value;
    }
    execCast(expr, scope) {
        const value = this.execExpr(expr.value, scope);
        return this._execCast(expr.type, value);
    }
    // tslint:disable-next-line:function-name
    _execCast(type, value) {
        // protected Object _execCast(String type, Object value){
        if (value == null || Array.isArray(value)) {
            return value;
        }
        if (type === 'int') {
            return value;
        }
        else if (type === 'double') {
            return value;
        }
        else if (type === 'long') {
            return value;
        }
        else if (type === 'char') {
            return value;
            // if (value instanceof Integer) {
            //   return (byte)((int)value);
            // }
            // else if(value instanceof Character) {
            //   return (byte)((char)value);
            // }
            // else if(value instanceof Long ) {
            //   return (byte)((long)value);
            // }
            // else if(value instanceof Character ) {
            //   return (byte)((char)value);
            // }
        }
        return value;
    }
    execCharLiteral(expr, scope) {
        const value = expr.value;
        const code = value.charCodeAt(0);
        return code;
    }
    execStringLiteral(expr, scope) {
        const value = expr.value;
        const list = [];
        for (let i = 0; i < value.length; ++i) {
            const byte = value.charCodeAt(i);
            list.push(byte);
        }
        list.push(0);
        return list;
    }
    *execNewArray(uniNewArray, scope) {
        const elementsNum = uniNewArray.elementsNum;
        const length = yield* this.execExpr(elementsNum[0], scope);
        const value = uniNewArray.value;
        let array = new Array(length).fill(0);
        if (value.items != null) {
            array = yield* this.execArray(value, scope);
            for (let i = array.length; i < length; ++i) {
                array.push(0);
            }
        }
        return array;
    }
    *execNew(newExpr, scope) {
        let className = newExpr.type;
        let value = '';
        const importsList = scope.getImportList();
        if (!scope.hasValue(className)) {
            for (const im of importsList) {
                const item = im.names.map((name) => new UniIdent_1.UniIdent(name));
                let rec = yield* this.execExpr(item[0], scope);
                for (let i = 1; i < item.length; ++i) {
                    if (item[i] instanceof UniIdent_1.UniIdent) {
                        rec = rec[item[i].name];
                    }
                    else {
                        rec = rec[yield* this.execExpr(item[i], scope)];
                    }
                }
                if (im.isOndemand) {
                    if (rec[className]) {
                        value = rec[className];
                        className = `${im.names.join('.')}.${className}`;
                    }
                }
                else {
                    if (rec) {
                        value = rec;
                        className = im.names.join('.');
                    }
                }
            }
        }
        const heapAddress = scope.setHeap(value, newExpr.type);
        // const uniClassDec: UniClassDec = scope.get(newExpr.type);
        return heapAddress;
    }
}
exports.Java8Engine = Java8Engine;
//# sourceMappingURL=Java8Engine.js.map