"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Python3Engine = void 0;
const agh = require("agh.sprintf");
const __1 = require("../..");
const RuntimeException_1 = require("../Engine/RuntimeException");
class Python3Engine extends __1.Engine {
    getEntryPoint(node) {
        if (node instanceof __1.UniProgram) {
            return new __1.UniFunctionDec('main', [], 'void', [], node.block);
        }
        return null;
    }
    loadLibarary(global) {
        this.importStandard(global);
    }
    importStandard(global) {
        global.setTop('print', (arg) => {
            const text = Array.isArray(arg) ? __1.Engine.bytesToStr(arg) : arg;
            const output = agh.sprintf(String(text)).replace('\\n', '\n');
            this.stdout(output + '\n');
        }, 'FUNCTION');
        global.setTop('int', (arg) => {
            return parseInt(arg, 10);
        }, 'FUNCTION');
        global.setTop('map', (func, arr) => {
            return arr.map(func);
        }, 'FUNCTION');
        global.setTop('input', function* (outtext) {
            if (typeof outtext !== 'undefined') {
                this.stdout(outtext.trim()); // ignore \n
            }
            ////////////////////////////////////////////
            const isStdinEmpty = this.getStdin() === '';
            if (isStdinEmpty) {
                this.setIsWaitingForStdin(true); // yield and set stdin
                yield; // get args from next(args) from execUniMethodCall
            }
            ////////////////////////////////////////////
            let input = this.getStdin();
            this.clearStdin();
            if (isStdinEmpty) {
                this.stdout(input + '\n');
            }
            const nPos = input.indexOf('\n');
            if (0 <= nPos) {
                this.stdin(input.substr(nPos + 1));
                input = input.substring(0, nPos);
            }
            if (isStdinEmpty) {
                this.setIsWaitingForStdin(false);
            }
            return input;
        }, 'FUNCTION');
        global.setTop('range', (n) => {
            return [...Array(n).keys()];
        }, 'FUNCTION');
    }
    *execBinOp(arg, scope, left, right) {
        if (arg instanceof __1.UniBinOp && left === undefined && right === undefined) {
            const binOp = arg;
            return yield* this.execBinOp(binOp.operator, scope, binOp.left, binOp.right);
        }
        else if (typeof arg === 'string' && left instanceof __1.UniExpr) {
            let op = arg;
            if (op === '++' || op === '--') {
                op = '_' + op;
                return yield* this.execUnaryOp(new __1.UniUnaryOp(op, left), scope);
            }
            if (right instanceof __1.UniExpr) {
                if (op === '=') {
                    const ret = yield* this.execAssignOrDec(left, right, scope);
                    yield ret;
                    return ret;
                }
                if (op === '.') {
                    if (left instanceof __1.UniMethodCall && right instanceof __1.UniMethodCall) {
                        if (right.methodName.name === 'split') {
                            const retLeft = yield* this.execMethoodCall(left, scope);
                            if (typeof retLeft === 'string') {
                                const ret = retLeft.split(' ');
                                yield ret;
                                return ret;
                            }
                        }
                    }
                }
                return yield* super.execBinOp(op, scope, left, right);
            }
        }
        else if (arg === null) {
            const validUbo = this.fixUniBinOp(new __1.UniBinOp(null, left, right));
            return yield* this.execExpr(validUbo, scope);
        }
    }
    *execVariableDecInitValue(def, decVar, scope) {
        let value = null;
        if (def.value instanceof __1.UniNode) {
            value = yield* super.execVariableDecInitValue(def, decVar, scope);
        }
        else {
            value = def.value;
        }
        decVar.type = this.checkValueType(value, def);
        return value;
    }
    checkValueType(value, def) {
        if (def.value instanceof __1.UniNumberLiteral) {
            return 'number';
        }
        else if (def.value instanceof __1.UniStringLiteral) {
            return 'string';
        }
        else if (def.value instanceof __1.UniBoolLiteral) {
            return 'number';
        }
        else if (typeof value === 'number') {
            return 'number';
        }
        else if (typeof value === 'string') {
            return 'string';
        }
        else if (Array.isArray(value)) {
            return this.checkValueType(value[0], def);
        }
        return 'undefined';
    }
    execBinOpImple(op, l, r) {
        if (op === '*') {
            if (Array.isArray(l)) {
                return [...Array(r)].reduce((prev) => prev.push(...l) && prev, []);
            }
            else if (Array.isArray(r)) {
                return [...Array(l)].reduce((prev) => prev.push(...r) && prev, []);
            }
        }
        return super.execBinOpImple(op, l, r);
    }
    *execAssignOrDec(left, right, scope) {
        if (left instanceof __1.UniIdent) {
            if (scope.hasValue(left.name)) {
                return yield* super.execBinOp('=', scope, left, right);
            }
            else {
                const uvd = new __1.UniVariableDec([], null, [new __1.UniVariableDef(left.name, right, '')]);
                return yield* this.execVariableDec(uvd, scope);
            }
        }
        else if (left instanceof __1.UniArray) {
            let ret = null;
            let rightArray = null;
            if (right instanceof __1.UniArray) {
                rightArray = right.items;
            }
            else if (Array.isArray(right)) {
                rightArray = right;
            }
            else if (right instanceof __1.UniExpr) {
                rightArray = yield* this.execExpr(right, scope);
            }
            for (let i = 0; i < left.items.length; ++i) {
                const l = left.items[i];
                const r = rightArray[i];
                ret = yield* this.execAssignOrDec(l, r, scope);
            }
            return ret;
        }
        else if (left instanceof __1.UniBinOp) {
            const validLeft = this.fixUniBinOp(left);
            return yield* super.execBinOp('=', scope, validLeft, right);
        }
        throw new RuntimeException_1.UniRuntimeError('unsupported assign or dec operation.');
    }
    fixUniBinOp(ubo) {
        const left = ubo.left;
        const right = ubo.right;
        const operator = ubo.operator;
        if (ubo instanceof __1.UniBinOp) {
            if (ubo.operator === null) {
                if (ubo.left instanceof __1.UniIdent &&
                    ubo.right instanceof __1.UniBinOp &&
                    ubo.right.left === null) {
                    if (ubo.right.operator === '[]') {
                        return new __1.UniBinOp('[]', ubo.left, ubo.right.right);
                    }
                }
            }
        }
        if (operator === null) {
            if (left instanceof __1.UniIdent && right instanceof __1.UniMethodCall && right.methodName === null) {
                return new __1.UniMethodCall(null, left, right.args);
            }
        }
        return ubo;
    }
}
exports.Python3Engine = Python3Engine;
//# sourceMappingURL=Python3Engine.js.map