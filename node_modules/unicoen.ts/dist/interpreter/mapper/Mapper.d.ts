import { CommonTokenStream, Parser, ParserRuleContext } from 'antlr4ts';
import { ErrorNode } from 'antlr4ts/tree/ErrorNode';
import { ParseTree } from 'antlr4ts/tree/ParseTree';
import { RuleNode } from 'antlr4ts/tree/RuleNode';
import { TerminalNode } from 'antlr4ts/tree/TerminalNode';
import { UniNode } from '../../node/UniNode';
import { UniProgram } from '../../node/UniProgram';
import { NodeComment } from './NodeComment';
import { SyntaxErrorData } from './SyntaxErrorData';
export declare abstract class Mapper {
    protected isDebugMode: boolean;
    protected parser: Parser;
    protected comments: NodeComment[];
    protected lastNode: UniNode;
    protected nextTokenIndex: number;
    protected stream: CommonTokenStream;
    setIsDebugMode(isDebugMode: boolean): void;
    preProcess(text: string): string;
    abstract parseToANTLRTree(code: any): ParserRuleContext;
    parseToUniTree(code: string): UniProgram;
    checkSyntaxError(code: string): SyntaxErrorData[];
    makeUniTree(tree: ParserRuleContext, tokens: CommonTokenStream): UniProgram;
    setNodeRangeAndComment(tree: ParseTree, ret: any): void;
    visit(tree: ParseTree): any;
    visitChildren(node: RuleNode): any;
    visitTerminal(node: TerminalNode): string;
    visitErrorNode(node: ErrorNode): UniNode;
    isNonEmptyNode(node: ParseTree): boolean;
    getRuleName(node: any): string;
    castToList<T extends Function | String>(obj: any, clazz: T): T[];
    castTo<T extends Function | String>(obj: any, clazz: any): any;
    protected flatten(obj: any): any;
}
