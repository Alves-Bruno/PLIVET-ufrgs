"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Mapper = void 0;
// tslint:disable:ban-types
const antlr4ts_1 = require("antlr4ts");
const UniExpr_1 = require("../../node/UniExpr");
const UniNode_1 = require("../../node/UniNode");
const UniProgram_1 = require("../../node/UniProgram");
const UniStatement_1 = require("../../node/UniStatement");
const CodeLocation_1 = require("../../node_helper/CodeLocation");
const CodeRange_1 = require("../../node_helper/CodeRange");
const NodeComment_1 = require("./NodeComment");
const SyntaxErrorListener_1 = require("./SyntaxErrorListener");
class Mapper {
    constructor() {
        this.isDebugMode = false;
        this.comments = [];
    }
    setIsDebugMode(isDebugMode) {
        this.isDebugMode = isDebugMode;
    }
    preProcess(text) {
        return text;
    }
    parseToUniTree(code) {
        const antTree = this.parseToANTLRTree(code);
        const uniTree = this.makeUniTree(antTree, this.parser.inputStream);
        return uniTree;
    }
    checkSyntaxError(code) {
        const antTree = this.parseToANTLRTree(code);
        const errorListeners = this.parser.getErrorListeners();
        for (const errorListener of errorListeners) {
            if (errorListener instanceof SyntaxErrorListener_1.SyntaxErrorListener) {
                return errorListener.getErrorMessages();
            }
        }
        return [];
    }
    makeUniTree(tree, tokens) {
        this.comments = [];
        this.stream = tokens;
        this.lastNode = null;
        this.nextTokenIndex = 0;
        const ret = new UniProgram_1.UniProgram(this.visit(tree));
        ret.codeRange = ret.block.codeRange;
        if (this.lastNode !== null) {
            const count = this.stream.getTokens().length - 1;
            for (let i = this.nextTokenIndex; i < count; i++) {
                const hiddenToken = this.stream.getTokens()[i]; // Includes skipped tokens (maybe)
                if (this.lastNode.comments === null) {
                    this.lastNode.comments = [];
                }
                this.lastNode.comments.push(hiddenToken.text);
            }
        }
        return ret;
    }
    setNodeRangeAndComment(tree, ret) {
        const node = Array.isArray(ret) && ret.length === 1 ? ret[0] : ret;
        if (node instanceof UniNode_1.UniNode) {
            if (tree instanceof antlr4ts_1.ParserRuleContext) {
                const start = tree.start;
                const begin = new CodeLocation_1.CodeLocation(start.charPositionInLine, start.line);
                const stop = tree.stop;
                const endPos = stop.charPositionInLine;
                const length = 1 + stop.stopIndex - stop.startIndex;
                const end = new CodeLocation_1.CodeLocation(endPos + length, stop.line);
                node.codeRange = new CodeRange_1.CodeRange(begin, end);
            }
            let contents = [];
            for (let i = this.comments.length - 1; i >= 0 && this.comments[i].parent === tree; i--) {
                for (const content of contents) {
                    this.comments[i].contents.push(content);
                }
                contents = this.comments[i].contents;
                this.comments.splice(i, 1);
            }
            if (contents.length > 0) {
                if (node.comments === null) {
                    node.comments = contents;
                }
                else {
                    node.comments = node.comments.concat(contents);
                }
            }
            this.lastNode = node;
        }
        else {
            for (let i = this.comments.length - 1; i >= 0 && this.comments[i].parent === tree; i--) {
                this.comments[i].parent = this.comments[i].parent.parent;
            }
            this.lastNode = null;
        }
    }
    visit(tree) {
        const accept = () => {
            const result = tree.accept(this);
            this.setNodeRangeAndComment(tree, result);
            return result;
        };
        if (!this.isDebugMode) {
            return accept();
        }
        if (!(tree instanceof antlr4ts_1.RuleContext)) {
            return accept();
        }
        const ruleName = this.getRuleName(tree);
        console.log('*** visit Rule : ' + ruleName + ' ***');
        const ret = accept();
        console.log('returned: ' + ret);
        return ret;
    }
    visitChildren(node) {
        const n = node.childCount;
        const list = [];
        for (let i = 0; i < n; ++i) {
            const c = node.getChild(i);
            const childResult = this.visit(c);
            list.push(childResult);
        }
        const flatten = this.flatten(list);
        return flatten;
    }
    visitTerminal(node) {
        if (this.isDebugMode) {
            console.log('visit TERMINAL : ' + node.text);
        }
        const token = node.symbol;
        if (token.type > 0) {
            const count = token.tokenIndex;
            const contents = [];
            let i = this.nextTokenIndex;
            for (; i < count; i++) {
                const hiddenToken = this.stream.getTokens()[i]; // Includes skipped tokens (maybe)
                if (this.lastNode !== null &&
                    this.stream.getTokens()[this.nextTokenIndex - 1].line === hiddenToken.line) {
                    if (this.lastNode.comments === null) {
                        this.lastNode.comments = [];
                    }
                    this.lastNode.comments.push(hiddenToken.text);
                }
                else {
                    contents.push(hiddenToken.text);
                }
            }
            const count2 = this.stream.getTokens().length - 1;
            for (i = count + 1; i < count2 &&
                this.stream.getTokens()[i].channel === antlr4ts_1.Token.HIDDEN_CHANNEL &&
                this.stream.getTokens()[count].line === this.stream.getTokens()[i].line; i++) {
                contents.push(this.stream.getTokens()[i].text);
            }
            if (contents.length > 0) {
                this.comments.push(new NodeComment_1.NodeComment(contents, node.parent));
            }
            this.nextTokenIndex = i;
        }
        return token.text;
    }
    visitErrorNode(node) {
        return null;
    }
    isNonEmptyNode(node) {
        if (node instanceof antlr4ts_1.ParserRuleContext) {
            const n = node.childCount;
            if (n > 1) {
                return true;
            }
            // n === 1 && node.children.exists[isNonEmptyNode]
            return n === 1;
        }
        else {
            return true;
        }
    }
    getRuleName(node) {
        return this.parser.ruleNames[node.ruleIndex];
    }
    castToList(obj, clazz) {
        const temp = this.flatten(obj);
        const ret = [];
        if (temp instanceof Map) {
            const add = temp.has('add');
            temp.forEach((value, key) => {
                switch (key) {
                    case 'add':
                        {
                            if (value instanceof Map) {
                                ret.push(this.castTo(value, clazz));
                            }
                            else if (Array.isArray(value)) {
                                value.forEach((it) => {
                                    const t = this.castTo(it, clazz);
                                    if (t != null) {
                                        ret.push(t);
                                    }
                                });
                            }
                            else {
                                ret.push(this.castToList(value, clazz));
                            }
                        }
                        break;
                    default:
                        if (!add) {
                            ret.push(this.castToList(value, clazz));
                        }
                        break;
                }
            });
        }
        else if (Array.isArray(temp)) {
            temp.forEach((it) => {
                ret.push(this.castToList(it, clazz));
            });
        }
        else {
            ret.push(this.castTo(temp, clazz));
        }
        return ret;
    }
    castTo(obj, clazz) {
        const temp = this.flatten(obj);
        const instance = new clazz();
        const fields = instance.fields;
        const fieldsName = [];
        for (const it in instance) {
            if (it) {
                fieldsName.push(it);
            }
        }
        if (temp instanceof Map) {
            if (clazz === String) {
                let builder = '';
                const hasAdd = temp.has('add');
                temp.forEach((value, key) => {
                    switch (key) {
                        case 'add':
                            {
                                builder += this.castTo(value, clazz);
                            }
                            break;
                        default:
                            {
                                if (!hasAdd) {
                                    builder += this.castTo(value, clazz);
                                }
                            }
                            break;
                    }
                });
                return builder.length > 0 ? builder : null;
            }
            temp.forEach((value, key) => {
                if (fieldsName.includes(key)) {
                    // tslint:disable-next-line:ban-types
                    const field = fields.get(key);
                    if (Array.isArray(instance[key])) {
                        const list = this.flatten(this.castToList(value, field));
                        if (!Array.isArray(list)) {
                            instance[key] = [list];
                        }
                        else {
                            instance[key] = list;
                        }
                    }
                    else if (value.length === 0 && (field === UniExpr_1.UniExpr || field === UniStatement_1.UniStatement)) {
                        instance[key] = null;
                    }
                    else {
                        instance[key] = this.castTo(value, field);
                    }
                }
            });
            return instance;
        }
        if (Array.isArray(temp)) {
            if (clazz === String) {
                let builder = '';
                temp.forEach((it) => {
                    builder += this.castTo(it, clazz);
                });
                return builder.length > 0 ? builder : null;
            }
            const first = temp.find((it) => {
                return it instanceof clazz;
            });
            if (first === null) {
                try {
                    return instance;
                }
                catch (e) {
                    return null;
                }
            }
            else {
                return this.castTo(first, clazz);
            }
        }
        if (temp != null) {
            return temp;
        }
        return instance;
    }
    flatten(obj) {
        if (Array.isArray(obj)) {
            if (obj.length === 1) {
                return this.flatten(obj[0]);
            }
            const ret = [];
            obj.forEach((it) => {
                ret.push(this.flatten(it));
            });
            return ret;
        }
        if (obj instanceof Map) {
            if (obj.size === 1) {
                for (const value of obj.values()) {
                    return this.flatten(value);
                }
            }
            const ret = new Map();
            obj.forEach((value, key) => {
                ret.set(key, this.flatten(value));
            });
            return ret;
        }
        return obj;
    }
}
exports.Mapper = Mapper;
//# sourceMappingURL=Mapper.js.map