import { UniArray } from '../../node/UniArray';
import { UniBinOp } from '../../node/UniBinOp';
import { UniBlock } from '../../node/UniBlock';
import { UniCast } from '../../node/UniCast';
import { UniCharacterLiteral } from '../../node/UniCharacterLiteral';
import { UniClassDec } from '../../node/UniClassDec';
import { UniDecralation } from '../../node/UniDecralation';
import { UniDoWhile } from '../../node/UniDoWhile';
import { UniEnhancedFor } from '../../node/UniEnhancedFor';
import { UniExpr } from '../../node/UniExpr';
import { UniFor } from '../../node/UniFor';
import { UniFunctionDec } from '../../node/UniFunctionDec';
import { UniIf } from '../../node/UniIf';
import { UniIntLiteral } from '../../node/UniIntLiteral';
import { UniMethodCall } from '../../node/UniMethodCall';
import { UniNode } from '../../node/UniNode';
import { UniProgram } from '../../node/UniProgram';
import { UniStatement } from '../../node/UniStatement';
import { UniStringLiteral } from '../../node/UniStringLiteral';
import { UniSwitch } from '../../node/UniSwitch';
import { UniUnaryOp } from '../../node/UniUnaryOp';
import { UniVariableDec } from '../../node/UniVariableDec';
import { UniVariableDef } from '../../node/UniVariableDef';
import { UniWhile } from '../../node/UniWhile';
import { ExecState } from './ExecState';
import { RuntimeException } from './RuntimeException';
import { Scope } from './Scope';
export declare class ControlException extends RuntimeException {
}
export declare class Break extends ControlException {
}
export declare class Continue extends ControlException {
}
export declare class Return extends ControlException {
    readonly value: any;
    constructor(value: any);
}
export declare class Exit extends Return {
}
export declare class Engine {
    static readonly structInfoSize = 4;
    static lastSizeOf: string;
    static executeSimpleExpr(expr: UniExpr, scope?: Scope): any;
    static executeSimpleProgram(program: UniProgram): any;
    static bytesToStr(obj: any): string;
    static sizeof(type: string): number;
    protected currentState: ExecState;
    protected currentScope: Scope;
    protected execStepItr: IterableIterator<any>;
    private isDebugMode;
    private isSetNextExpr;
    private stdoutText;
    private stdinText;
    private isWaitingForStdin;
    setDebugMode(enable: boolean): void;
    getCurrentValue(): ExecState;
    getCurrentExpr(): UniNode;
    getCurrentState(): ExecState;
    getStdout(): string;
    stdin(text: string): void;
    getIsWaitingForStdin(): boolean;
    setIsWaitingForStdin(enable: boolean): boolean;
    isStepExecutionRunning(): boolean;
    setFileList(filelist: Map<string, ArrayBuffer>): void;
    startStepExecution(dec: UniProgram): ExecState;
    stepExecute(): ExecState;
    execute(dec: UniProgram): any;
    toDouble(obj: any): number;
    toBool(obj: any): boolean;
    protected stopByYield(ret: any, nextExpr: UniExpr): Generator<any, void, unknown>;
    protected executeStepByStep(dec: UniProgram): Generator<any, any, any>;
    protected execUnaryOp(uniOp: UniUnaryOp, scope: Scope): any;
    protected getAddress(expr: UniExpr, scope: Scope): any;
    protected execArray(uniArray: UniArray, scope: Scope): Generator<any, any[], any>;
    protected execVariableDecInitValue(def: UniVariableDef, decVar: UniVariableDec, scope: Scope): Generator<any, any, any>;
    protected execVariableDec(decVar: UniVariableDec, scope: Scope): Generator<any, any, any>;
    protected stdout(text: string): void;
    protected getStdin(): string;
    protected loadLibarary(global: Scope): void;
    protected execDecralation(dec: UniDecralation, scope: Scope): Generator<any, any, any>;
    protected execStatement(state: UniStatement, scope: Scope): any;
    protected execBlock(block: UniBlock, scope: Scope): Generator<any, any, any>;
    protected execIf(ui: UniIf, scope: Scope): Generator<any, any, any>;
    protected execFor(uf: UniFor, scope: Scope): Generator<any, any, any>;
    protected execEnhancedFor(euf: UniEnhancedFor, scope: Scope): Generator<any, any, any>;
    protected execWhile(uw: UniWhile, scope: Scope): Generator<any, any, any>;
    protected execDoWhile(udw: UniDoWhile, scope: Scope): Generator<any, any, any>;
    protected execSwitch(us: UniSwitch, scope: Scope): Generator<any, any, any>;
    protected execExpr(expr: UniExpr, scope: Scope): any;
    protected execCast(expr: UniCast, scope: Scope): any;
    protected _execCast(type: string, value: any): any;
    protected execCharLiteral(expr: UniCharacterLiteral, scope: Scope): any;
    protected execStringLiteral(expr: UniStringLiteral, scope: Scope): any;
    protected execIntLiteral(expr: UniIntLiteral, scope: Scope): any;
    protected execBinOp(binOp: UniBinOp, scope: Scope): any;
    protected execBinOp(op: string, scope: Scope, left: UniExpr, right: UniExpr): any;
    protected execBinOpImple(op: string, l: any, r: any): any;
    protected execAssign(address: number, value: any, scope: Scope): any;
    protected getType(expr: UniExpr, scope: Scope): string;
    protected randInt32(): number;
    protected rand(bit: number): number;
    protected execMethoodCall(mc: UniMethodCall, scope: Scope): Generator<any, any, any>;
    protected _execExpr(expr: UniExpr, scope: Scope): any;
    protected execClassDec(dec: UniClassDec, scope: Scope): void;
    protected clearStdout(): void;
    protected clearStdin(): void;
    protected getEntryPoint(node: UniNode): UniFunctionDec;
    private setGlobalObjects;
    private execFunc;
    private execFuncCall;
}
