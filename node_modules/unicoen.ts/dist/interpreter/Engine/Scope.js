"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Scope = void 0;
// tslint:disable:max-classes-per-file
const UniExpr_1 = require("../../node/UniExpr");
const UniFunctionDec_1 = require("../../node/UniFunctionDec");
const clone_1 = require("../../node_helper/clone");
const Engine_1 = require("./Engine");
const File_1 = require("./File");
const RuntimeException_1 = require("./RuntimeException");
var Type;
(function (Type) {
    Type[Type["GLOBAL"] = 0] = "GLOBAL";
    Type[Type["OBJECT"] = 1] = "OBJECT";
    Type[Type["LOCAL"] = 2] = "LOCAL";
})(Type || (Type = {}));
class Address {
    constructor(codeAddress, staticAddress, heapAddress, stackAddress) {
        this.codeAddress = codeAddress;
        this.staticAddress = staticAddress;
        this.heapAddress = heapAddress;
        this.stackAddress = stackAddress;
    }
}
class ValueSetter {
    accept(value) {
        this.hasValue = true;
        this.value = value;
    }
}
class Import {
    constructor(names, isOndemand) {
        this.names = names;
        this.isOndemand = isOndemand;
    }
}
class Scope {
    constructor(type, parent) {
        this.children = [];
        this.variableAddress = new Map();
        this.variableTypes = new Map();
        this.listeners = null;
        this.tempAddressForListener = -1;
        this.toReturnAddress = -1;
        this.ImportsList = [];
        this.parent = parent;
        this.type = type;
        if (parent === null) {
            this.depth = 0;
            this.name = 'GLOBAL';
            this.global = this;
            this.address = new Address(0, 10000, 20000, 50000);
            this.toReturnAddress = 0;
            this.mallocData = new Map();
            this.objectOnMemory = new Map();
            this.typeOnMemory = new Map();
            this.functionAddress = new Map();
            this.typedefList = new Map();
        }
        else {
            parent.children.push(this);
            this.depth = parent.depth + 1;
            this.name = parent.name;
            this.global = parent.global;
            this.address = parent.address;
            this.toReturnAddress = this.address.stackAddress;
            this.address.stackAddress++;
            this.mallocData = parent.mallocData;
            this.objectOnMemory = parent.objectOnMemory;
            this.typeOnMemory = parent.typeOnMemory;
            this.functionAddress = parent.functionAddress;
            this.typedefList = parent.typedefList;
            this.ImportsList = clone_1.clone(parent.ImportsList);
        }
    }
    static createGlobal() {
        return new Scope(Type.GLOBAL, null);
    }
    static createObject(global) {
        console.assert(global != null);
        console.assert(global.type === Type.GLOBAL); // 匿名クラスは未対応
        return new Scope(Type.OBJECT, global);
    }
    static createLocal(parent) {
        console.assert(parent != null);
        return new Scope(Type.LOCAL, parent);
    }
    static assertNotUnicoen(value) {
        if (value instanceof UniExpr_1.UniExpr && !(value instanceof UniFunctionDec_1.UniFunctionDec)) {
            throw new RuntimeException_1.RuntimeException('Maybe programming miss!');
        }
    }
    setListener(listener) {
        if (this.listeners == null) {
            this.listeners = [];
        }
        this.listeners.push(listener);
    }
    hasType(key) {
        try {
            this.getType(key);
            return true;
        }
        catch (err) {
            if (err instanceof RuntimeException_1.UniRuntimeError) {
                return false;
            }
            throw err;
        }
    }
    isStructType(type) {
        try {
            const rawType = this.getTypedef(type);
            const offsetsOrType = this.get(rawType);
            if (offsetsOrType instanceof Map) {
                return true;
            }
            return this.isStructType(offsetsOrType);
        }
        catch (err) {
            if (err instanceof RuntimeException_1.UniRuntimeError) {
                return false;
            }
            throw err;
        }
    }
    setTypedef(oldType, newType) {
        this.typedefList.set(newType, oldType);
    }
    getTypedef(newType) {
        if (this.typedefList.has(newType)) {
            return this.typedefList.get(newType);
        }
        else {
            return newType;
        }
    }
    hasValue(key) {
        try {
            this.getValue(this.getAddress(key));
            return true;
        }
        catch (err) {
            if (err instanceof RuntimeException_1.UniRuntimeError) {
                return false;
            }
            throw err;
        }
    }
    get(key) {
        return this.getValue(this.getAddress(key));
    }
    getValue(key) {
        return this.getValueImple(key, this.name);
    }
    getStr(name) {
        const addr = this.getAddress(name);
        const buf = [];
        let i = 0;
        for (; i < 10000; ++i) {
            const b = this.getValue(addr + i);
            if (b === 0) {
                break;
            }
            buf.push(b);
        }
        // tslint:disable-next-line:prefer-array-literal
        const array = new Array(i);
        for (let k = 0; k < i; ++k) {
            array[k] = /* get */ buf[k];
        }
        const result = String.fromCharCode.apply(null, array);
        return result;
    }
    // typedefを考慮したgetType
    getRawType(key) {
        return this.getTypedef(this.getType(key));
    }
    // 変数名 or 変数のアドレス
    getType(key) {
        if (typeof key === 'string') {
            if (this.variableTypes.has(key)) {
                return this.variableTypes.get(key);
            }
            else if (this.parent != null) {
                return this.parent.getType(key);
            }
        }
        if (typeof key === 'number') {
            if (this.typeOnMemory.has(key)) {
                return this.typeOnMemory.get(key);
            }
            else if (this.parent != null) {
                return this.parent.getType(key);
            }
        }
        throw new RuntimeException_1.UniRuntimeError(`variable ${key} is not defined.`);
    }
    getAddress(key) {
        if (this.variableAddress.has(key)) {
            return this.variableAddress.get(key);
        }
        else if (this.parent != null) {
            return this.parent.getAddress(key);
        }
        else if (this.listeners != null) {
            const setter = new ValueSetter();
            for (const listener of this.listeners) {
                listener.variableNotFound(key, setter);
                if (setter.hasValue) {
                    this.objectOnMemory.set(this.tempAddressForListener, setter.value);
                    return -1;
                }
            }
        }
        throw new RuntimeException_1.UniRuntimeError(`variable ${key} is not defined.`);
    }
    setMallocSize(address, size) {
        this.mallocData.set(address, size);
    }
    isMallocArea(address) {
        return this.mallocData.has(address);
    }
    getMallocSize(address) {
        return this.mallocData.get(address);
    }
    removeOnMemory(address, size) {
        let result = true;
        for (let i = 0; i < size; ++i) {
            result = this.objectOnMemory.delete(address + i) != null;
            result = this.typeOnMemory.delete(address + i) != null;
        }
        return result;
    }
    setHeap(value, type) {
        return this.setAreaImple(value, type, this.address, 'heapAddress');
    }
    setStatic(value, type) {
        return this.setAreaImple(value, type, this.address, 'staticAddress');
    }
    setCode(value, type) {
        return this.setAreaImple(value, type, this.address, 'codeAddress');
    }
    setSystemVariable(type, name, value) {
        Scope.assertNotUnicoen(value);
        const addr = this.address.codeAddress;
        this.variableTypes.set(name, type);
        this.variableAddress.set(name, addr);
        this.objectOnMemory.set(addr, value);
        this.typeOnMemory.set(addr, type);
        const size = Scope.sizeof(type);
        this.address.codeAddress += size;
        return addr;
    }
    setStruct(key, value, type) {
        // 構造体
        const rawType = this.getTypedef(type);
        // [offset, type]のタプル
        const offsets = this.get(rawType);
        let arr = null;
        if (value instanceof Array) {
            // 初期化リストあり
            arr = value;
            for (let i = arr.length; i < offsets.size; ++i) {
                arr.push(0);
            }
        }
        else if (typeof value === 'number') {
            // コピー
            arr = [];
            for (const valueofOffset of offsets.values()) {
                let addr = value;
                addr += valueofOffset[0];
                const v = this.getValue(addr);
                arr.push(v);
            }
        }
        else {
            // 宣言のみ
            arr = [];
            for (let i = 0; i < offsets.size; ++i) {
                arr.push(null);
            }
        }
        let k = 0;
        for (const [fieldName, valueofOffset] of offsets) {
            const fieldType = valueofOffset[1];
            const offset = valueofOffset[2];
            const v = arr[k++];
            Scope.assertNotUnicoen(value);
            if (this.isStructType(fieldType)) {
                this.typeOnMemory.set(this.address.stackAddress, fieldType);
                // JSは関数の引数は左から評価される。
                this.objectOnMemory.set(this.address.stackAddress, this.address.stackAddress + Engine_1.Engine.structInfoSize);
                this.address.stackAddress += Engine_1.Engine.structInfoSize;
                this.setStruct(fieldName, v, fieldType);
            }
            else if (v instanceof Array) {
                this.setArray(v, type, [v.length]);
                this.address.stackAddress += offset;
            }
            else {
                this.typeOnMemory.set(this.address.stackAddress, fieldType);
                this.objectOnMemory.set(this.address.stackAddress, v);
                this.address.stackAddress += offset;
            }
        }
    }
    getArrayDims(arrObjOrTypeStr) {
        const dims = [];
        if (typeof arrObjOrTypeStr === 'string') {
            const typeStr = arrObjOrTypeStr;
            for (let k = 0; k < typeStr.length; ++k) {
                const left = typeStr.indexOf('[', k);
                const right = typeStr.indexOf(']', k);
                const size = typeStr.slice(left + 1, right);
                dims.push(Number.parseInt(size, 10));
                k = right;
            }
        }
        else if (Array.isArray(arrObjOrTypeStr)) {
            let arr = arrObjOrTypeStr;
            while (Array.isArray(arr)) {
                dims.push(arr.length);
                if (0 < arr.length) {
                    arr = arr[0];
                }
            }
        }
        return dims;
    }
    /** 現在のスコープに新しい変数を定義し、代入します */
    setTop(key, value, type) {
        Scope.assertNotUnicoen(value);
        if (type === 'FUNCTION' || value instanceof UniFunctionDec_1.UniFunctionDec) {
            this.setPrimitiveOnCode(key, value, type);
        }
        else if (this.isStructType(type)) {
            // 構造体
            this.setPrimitive(key, this.address.stackAddress + 4, type);
            this.setStruct(key, value, type);
        }
        else if (value instanceof Array) {
            // 配列の場合
            const arr = value;
            if (type === 'char*') {
                // 文字列の場合(char*の場合, char[], char[10]の場合は↓)
                arr.push(0);
                this.setPrimitive(key, this.address.codeAddress, type);
                this.setStringOnCode(arr);
            }
            else {
                const dims = this.getArrayDims(arr);
                const addr = this.setArray(arr, type, dims.slice(1));
                this.setPrimitiveOnCode(key, addr, type + '[' + dims.join('][') + ']');
            }
        }
        else {
            // 組み込み型の場合
            this.setPrimitive(key, value, type);
        }
    }
    /** 指定したメモリアドレスに値を書き込みます */
    set(addr, value) {
        Scope.assertNotUnicoen(value);
        if (this.objectOnMemory.has(addr)) {
            const type = this.getRawType(addr);
            if (this.isStructType(type)) {
                const offsets = this.get(type);
                for (const valueOfOffset of offsets.values()) {
                    // srcとdstはどちらもstructを想定
                    const dst = this.getValue(addr) + valueOfOffset[0];
                    const src = value + valueOfOffset[0];
                    const v = this.getValue(src);
                    this.objectOnMemory.set(dst, v);
                }
            }
            else {
                this.objectOnMemory.set(addr, value);
            }
            return;
        }
        if (this.parent != null) {
            this.parent.set(addr, value);
            return;
        }
        throw new RuntimeException_1.UniRuntimeError(`address ${addr} is not declared.`);
    }
    removeChild(scope) {
        const toReturnAddress = scope.toReturnAddress;
        if (this.children.remove(scope)) {
            this.address.stackAddress = toReturnAddress;
            return true;
        }
        return false;
    }
    getNextName(funcName) {
        if (!this.hasName(funcName)) {
            return funcName;
        }
        for (let i = 2;; ++i) {
            const indexName = funcName + '.' + i;
            if (!this.hasName(indexName)) {
                return indexName;
            }
        }
    }
    closeAllFiles() {
        for (const value of this.objectOnMemory.values()) {
            if (value instanceof File_1.File) {
                value.fclose();
            }
        }
    }
    addImport(im) {
        const isOndemand = im.ondemand !== null && im.ondemand === '*';
        const names = im.name.split('.');
        this.ImportsList.push(new Import(names, isOndemand));
    }
    getImportList() {
        return this.ImportsList;
    }
    getValueImple(key, stackName) {
        if (this.objectOnMemory.has(key)) {
            const variable = this.objectOnMemory.get(key);
            if (stackName === this.name || this.type === Type.GLOBAL) {
                if (key === this.tempAddressForListener) {
                    this.objectOnMemory.delete(this.tempAddressForListener);
                }
                return variable;
            }
        }
        if (this.parent != null) {
            return this.parent.getValue(key);
        }
        else {
            throw new RuntimeException_1.UniRuntimeError(`variable ${key} is not defined.`);
        }
    }
    setAreaImple(value, type, addr, member) {
        Scope.assertNotUnicoen(value);
        const ret = addr[member];
        this.objectOnMemory.set(addr[member], value);
        this.typeOnMemory.set(addr[member], type);
        const size = Scope.sizeof(type);
        addr[member] += size;
        return ret;
    }
    setArray(value, type, dims) {
        Scope.assertNotUnicoen(value);
        let ret = null;
        const addrs = [];
        if (value.every((v) => Array.isArray(v))) {
            for (const v of value) {
                const addr = this.setArray(v, type, dims.slice(1));
                addrs.push(addr);
            }
            if (ret == null) {
                ret = this.address.codeAddress;
            }
            for (const addr of addrs) {
                this.setAreaImple(addr, type + '[' + dims.join('][') + ']', this.address, 'codeAddress');
            }
        }
        else {
            for (const v of value) {
                const addr = this.setAreaImple(v, type, this.address, 'stackAddress');
                if (ret == null) {
                    ret = addr;
                }
            }
        }
        console.log(this.objectOnMemory);
        console.log(this.typeOnMemory);
        return ret;
    }
    setStringOnCode(value) {
        Scope.assertNotUnicoen(value);
        for (const v of value) {
            if (v instanceof Array) {
                this.setStringOnCode(v);
            }
            else {
                this.typeOnMemory.set(this.address.codeAddress, 'char');
                this.objectOnMemory.set(this.address.codeAddress++, v);
            }
        }
    }
    setImple(key, value, type, address, member) {
        Scope.assertNotUnicoen(value);
        this.variableTypes.set(key, type);
        this.variableAddress.set(key, address[member]);
        this.objectOnMemory.set(address[member], value);
        this.typeOnMemory.set(address[member], type);
        const size = Scope.sizeof(type);
        address[member] += size;
    }
    setPrimitive(key, value, type) {
        this.setImple(key, value, type, this.address, 'stackAddress');
    }
    setPrimitiveOnCode(key, value, type) {
        this.setImple(key, value, type, this.address, 'codeAddress');
    }
    setPrimitiveOnHeap(key, value, type) {
        this.setImple(key, value, type, this.address, 'heapAddress');
    }
    setPrimitiveOnStatic(key, value, type) {
        this.setImple(key, value, type, this.address, 'staticAddress');
    }
    hasName(funcName) {
        if (this.name === funcName) {
            return true;
        }
        else if (this.parent != null) {
            return this.parent.hasName(funcName);
        }
        return false;
    }
}
exports.Scope = Scope;
//# sourceMappingURL=Scope.js.map