"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Engine = exports.Exit = exports.Return = exports.Continue = exports.Break = exports.ControlException = void 0;
const UniArray_1 = require("../../node/UniArray");
const UniBinOp_1 = require("../../node/UniBinOp");
const UniBlock_1 = require("../../node/UniBlock");
const UniBoolLiteral_1 = require("../../node/UniBoolLiteral");
const UniBreak_1 = require("../../node/UniBreak");
const UniCast_1 = require("../../node/UniCast");
const UniCharacterLiteral_1 = require("../../node/UniCharacterLiteral");
const UniClassDec_1 = require("../../node/UniClassDec");
const UniContinue_1 = require("../../node/UniContinue");
const UniDecralation_1 = require("../../node/UniDecralation");
const UniDoWhile_1 = require("../../node/UniDoWhile");
const UniEmptyStatement_1 = require("../../node/UniEmptyStatement");
const UniEnhancedFor_1 = require("../../node/UniEnhancedFor");
const UniExpr_1 = require("../../node/UniExpr");
const UniFor_1 = require("../../node/UniFor");
const UniFunctionDec_1 = require("../../node/UniFunctionDec");
const UniIdent_1 = require("../../node/UniIdent");
const UniIf_1 = require("../../node/UniIf");
const UniImportDec_1 = require("../../node/UniImportDec");
const UniIntLiteral_1 = require("../../node/UniIntLiteral");
const UniJump_1 = require("../../node/UniJump");
const UniLabel_1 = require("../../node/UniLabel");
const UniMethodCall_1 = require("../../node/UniMethodCall");
const UniNumberLiteral_1 = require("../../node/UniNumberLiteral");
const UniProgram_1 = require("../../node/UniProgram");
const UniReturn_1 = require("../../node/UniReturn");
const UniStatement_1 = require("../../node/UniStatement");
const UniStringLiteral_1 = require("../../node/UniStringLiteral");
const UniSwitch_1 = require("../../node/UniSwitch");
const UniTernaryOp_1 = require("../../node/UniTernaryOp");
const UniUnaryOp_1 = require("../../node/UniUnaryOp");
const UniVariableDec_1 = require("../../node/UniVariableDec");
const UniVariableDef_1 = require("../../node/UniVariableDef");
const UniWhile_1 = require("../../node/UniWhile");
const clone_1 = require("../../node_helper/clone");
const ExecState_1 = require("./ExecState");
const File_1 = require("./File");
const RuntimeException_1 = require("./RuntimeException");
const Scope_1 = require("./Scope");
// tslint:disable:max-classes-per-file
class ControlException extends RuntimeException_1.RuntimeException {
}
exports.ControlException = ControlException;
class Break extends ControlException {
}
exports.Break = Break;
class Continue extends ControlException {
}
exports.Continue = Continue;
class Return extends ControlException {
    constructor(value) {
        super();
        this.value = value;
    }
}
exports.Return = Return;
class Exit extends Return {
}
exports.Exit = Exit;
class Engine {
    constructor() {
        this.currentState = null;
        this.currentScope = null;
        this.execStepItr = null;
        this.isDebugMode = false;
        this.isSetNextExpr = false;
        this.stdoutText = '';
        this.stdinText = '';
        this.isWaitingForStdin = false;
    }
    static executeSimpleExpr(expr, scope) {
        if (scope === undefined) {
            return new Engine().execExpr(expr, scope);
        }
        return this.executeSimpleExpr(expr, Scope_1.Scope.createGlobal());
    }
    static executeSimpleProgram(program) {
        return this.executeSimpleExpr(program.block, Scope_1.Scope.createGlobal());
    }
    // Byte[]
    static bytesToStr(obj) {
        const bytes = obj;
        const pos = bytes.indexOf(0);
        const length = pos === -1 ? bytes.length : pos;
        // new String(data);
        let str = '';
        for (let i = 0; i < length; ++i) {
            str += String.fromCharCode(bytes[i]);
        }
        return str;
    }
    // ToDo: structに対応するためstaticを外しscopeからsizeを取得する
    static sizeof(type) {
        if (type.includes('*')) {
            return 4;
        }
        else if (type.includes('char')) {
            return 1;
        }
        else if (type.includes('short')) {
            return 2;
        }
        else if (type.includes('double')) {
            return 8;
        }
        return 4;
    }
    setDebugMode(enable) {
        this.isDebugMode = enable;
    }
    getCurrentValue() {
        return this.currentState.getCurrentValue();
    }
    getCurrentExpr() {
        return this.currentState.getCurrentExpr();
    }
    getCurrentState() {
        return this.currentState;
    }
    getStdout() {
        return this.stdoutText;
    }
    stdin(text) {
        this.stdinText += text;
    }
    getIsWaitingForStdin() {
        return this.isWaitingForStdin;
    }
    setIsWaitingForStdin(enable) {
        return (this.isWaitingForStdin = enable);
    }
    isStepExecutionRunning() {
        return this.execStepItr != null;
    }
    setFileList(filelist) {
        File_1.File.setFilelist(filelist);
    }
    startStepExecution(dec) {
        this.execStepItr = this.executeStepByStep(dec);
        return this.stepExecute();
    }
    stepExecute() {
        if (this.execStepItr == null) {
            return this.getCurrentState();
        }
        this.isSetNextExpr = false;
        let node;
        do {
            node = this.execStepItr.next();
        } while (!node.done && !this.isSetNextExpr && !this.isWaitingForStdin);
        const ret = node.value;
        this.currentState.setCurrenValue(ret);
        if (this.isDebugMode) {
            console.log(ret);
        }
        if (node.done) {
            this.execStepItr = null;
        }
        this.currentState.make();
        console.log(this.getCurrentState().getStacks());
        return clone_1.clone(this.currentState);
    }
    execute(dec) {
        let ret = 0;
        let node;
        const gen = this.executeStepByStep(dec);
        do {
            node = gen.next();
            ret = node.value;
            if (this.isDebugMode) {
                console.log(ret);
            }
        } while (!node.done);
        // this.currentState.make();
        this.currentState.setCurrenValue(ret);
        return ret;
    }
    toDouble(obj) {
        if (obj instanceof Number) {
            return obj;
        }
        throw new Error('Cannot covert to integer: ' + obj);
    }
    toBool(obj) {
        if (typeof obj === 'boolean') {
            return obj;
        }
        else if (obj instanceof Number) {
            return obj !== 0;
        }
        throw new Error('Cannot covert to boolean: ' + obj);
    }
    // use this method where you think a step exec.
    // yield* this.stopByYield(ret, nextExpr);
    *stopByYield(ret, nextExpr) {
        if (!this.isSetNextExpr) {
            this.currentState.setNextExpr(nextExpr);
            this.isSetNextExpr = true;
        }
        yield ret;
    }
    *executeStepByStep(dec) {
        const main = this.getEntryPoint(dec);
        if (main != null) {
            const global = Scope_1.Scope.createGlobal();
            this.setGlobalObjects(dec, global);
            this.loadLibarary(global);
            this.currentState = new ExecState_1.ExecState(global);
            this.clearStdout();
            // loadLibarary(global);
            // firePreExecAll(global);
            // 初期化が完了して1行目に入る前の状態で最初は返す。
            this.currentState.setCurrentExpr(dec);
            yield true;
            const value = yield* this.execFunc(main, global, null);
            // firePostExecAll(global, value);
            global.closeAllFiles();
            return value;
        }
        else {
            throw new RuntimeException_1.RuntimeException('No entry point in ' + dec);
        }
    }
    *execUnaryOp(uniOp, scope) {
        switch (uniOp.operator) {
            case '!':
                return !this.toBool(yield* this.execExpr(uniOp.expr, scope));
            case '-': {
                const value = yield* this.execExpr(uniOp.expr, scope);
                if (value === 'number') {
                    return -value;
                }
            }
            case '_++':
            case '++_':
            case '_--':
            case '--_':
                if (uniOp.expr instanceof UniIdent_1.UniIdent) {
                    const ident = uniOp.expr;
                    const num = (yield* this.execExpr(uniOp.expr, scope));
                    const address = yield* this.getAddress(ident, scope);
                    switch (uniOp.operator) {
                        case '_++':
                            this.execAssign(address, num + 1, scope);
                            yield num;
                            return num;
                        case '++_':
                            yield num + 1;
                            return this.execAssign(address, num + 1, scope);
                        case '_--':
                            this.execAssign(address, num - 1, scope);
                            yield num;
                            return num;
                        case '--_':
                            yield num + 1;
                            return this.execAssign(address, num - 1, scope);
                    }
                }
            case '()': {
                const v = yield* this.execExpr(uniOp.expr, scope);
                return v;
            }
        }
        throw new RuntimeException_1.RuntimeException('Unkown binary operator: ' + uniOp.operator);
    }
    *getAddress(expr, scope) {
        if (expr instanceof UniIdent_1.UniIdent) {
            const ui = expr;
            return scope.getAddress(ui.name);
        }
        else if (expr instanceof UniUnaryOp_1.UniUnaryOp) {
            const uuo = expr;
            if (uuo.operator === '*') {
                const refAddress = yield* this.execExpr(uuo.expr, scope);
                return refAddress;
            }
        }
        else if (expr instanceof UniBinOp_1.UniBinOp) {
            const ubo = expr;
            if (ubo.operator === '[]') {
                let elemTypeSize = 1;
                if (ubo.left instanceof UniIdent_1.UniIdent) {
                    let type = scope.getRawType(ubo.left.name);
                    while (type.endsWith('*')) {
                        type = type.substr(0, type.length - 1);
                    }
                    elemTypeSize = Engine.sizeof(type);
                }
                else if (ubo.right instanceof UniIdent_1.UniIdent) {
                    // 1[a] のようなトリッキーなケース
                    const type = scope.getRawType(ubo.right.name);
                    elemTypeSize = Engine.sizeof(type);
                }
                else {
                    let l = ubo.left;
                    while (l instanceof UniBinOp_1.UniBinOp) {
                        l = l.left;
                        if (l instanceof UniIdent_1.UniIdent) {
                            elemTypeSize = Engine.sizeof(scope.getRawType(l.name));
                            break;
                        }
                    }
                }
                return yield* this.getAddress(new UniUnaryOp_1.UniUnaryOp('*', new UniBinOp_1.UniBinOp('+', ubo.left, new UniBinOp_1.UniBinOp('*', new UniIntLiteral_1.UniIntLiteral(elemTypeSize), ubo.right))), scope);
            }
            else if (ubo.operator === '->') {
                return yield* this.getAddress(new UniBinOp_1.UniBinOp('.', new UniUnaryOp_1.UniUnaryOp('*', ubo.left), ubo.right), scope);
            }
            else if (ubo.operator === '.') {
                const startAddress = yield* this.execExpr(ubo.left, scope);
                let type = scope.getRawType(startAddress - 4);
                if (ubo.left instanceof UniUnaryOp_1.UniUnaryOp && ubo.left.operator === '*') {
                    while (type.endsWith('*')) {
                        type = type.substring(0, type.length - 1);
                    }
                }
                const offsets = scope.get(type);
                const offset = offsets.get(ubo.right.name);
                return startAddress + offset[0];
            }
        }
        throw new RuntimeException_1.RuntimeException('Assignment failure: ' + expr);
    }
    *execArray(uniArray, scope) {
        const elements = uniArray.items;
        const array = [];
        for (const element of elements) {
            const e = yield* this.execExpr(element, scope);
            array.push(e);
        }
        return array;
    }
    *execVariableDecInitValue(def, decVar, scope) {
        // 初期化されている場合
        let value = null;
        if (def.value != null) {
            value = yield* this.execExpr(def.value, scope);
            value = this._execCast(decVar.type, value);
        }
        // 配列の場合
        let length = 0;
        if (def.typeSuffix != null && def.typeSuffix !== '') {
            const sizes = [];
            const typeSuffix = def.typeSuffix;
            for (let k = 0; k < typeSuffix.length; ++k) {
                const left = typeSuffix.indexOf('[', k);
                const right = typeSuffix.indexOf(']', k);
                const size = typeSuffix.slice(left + 1, right);
                sizes.push(Number.parseInt(size, 10));
                k = right;
            }
            if (0 < sizes.length) {
                if (sizes.length === 1) {
                    length = sizes[0];
                    if (value != null) {
                        // 初期化している場合。
                        for (let i = value.length; i < length; ++i) {
                            value.push(0);
                        }
                    }
                    else {
                        value = [];
                        for (let i = 0; i < length; ++i) {
                            value.push(this.randInt32());
                        }
                    }
                }
                else if (sizes.length === 2) {
                    length = sizes[0];
                    if (value != null) {
                        // 初期化している場合。
                        for (let i = value.length; i < length; ++i) {
                            value.push(0);
                        }
                    }
                    else {
                        value = [];
                        for (let i = 0; i < length; ++i) {
                            const value2 = [];
                            const length2 = sizes[1];
                            for (let k = 0; k < length2; ++k) {
                                value2.push(this.randInt32());
                            }
                            value.push(value2);
                        }
                    }
                }
            }
        }
        return value;
    }
    *execVariableDec(decVar, scope) {
        let value = null;
        Engine.lastSizeOf = decVar.type;
        for (const def of decVar.variables) {
            value = yield* this.execVariableDecInitValue(def, decVar, scope);
            scope.setTop(def.name, value, decVar.type);
        }
        Engine.lastSizeOf = '';
        return value;
    }
    stdout(text) {
        this.stdoutText += text;
    }
    getStdin() {
        return this.stdinText;
    }
    loadLibarary(global) {
        return;
    }
    *execDecralation(dec, scope) {
        if (dec instanceof UniVariableDec_1.UniVariableDec) {
            const uvd = dec;
            return yield* this.execVariableDec(uvd, scope);
        }
        if (dec instanceof UniFunctionDec_1.UniFunctionDec) {
            return;
        }
        if (dec instanceof UniClassDec_1.UniClassDec) {
            return;
        }
    }
    *execStatement(state, scope) {
        if (state instanceof UniIf_1.UniIf) {
            return yield* this.execIf(state, scope);
        }
        else if (state instanceof UniFor_1.UniFor) {
            return yield* this.execFor(state, scope);
        }
        else if (state instanceof UniEnhancedFor_1.UniEnhancedFor) {
            return yield* this.execEnhancedFor(state, scope);
        }
        else if (state instanceof UniWhile_1.UniWhile) {
            return yield* this.execWhile(state, scope);
        }
        else if (state instanceof UniDoWhile_1.UniDoWhile) {
            return yield* this.execDoWhile(state, scope);
        }
        else if (state instanceof UniBreak_1.UniBreak) {
            throw new Break();
        }
        else if (state instanceof UniContinue_1.UniContinue) {
            throw new Continue();
        }
        else if (state instanceof UniReturn_1.UniReturn) {
            throw new Return(yield* this.execExpr(state.value, scope));
        }
        else if (state instanceof UniBlock_1.UniBlock) {
            return yield* this.execBlock(state, scope);
        }
        else if (state instanceof UniSwitch_1.UniSwitch) {
            return yield* this.execSwitch(state, scope);
        }
        else if (state instanceof UniEmptyStatement_1.UniEmptyStatement) {
            return null;
        }
        else if (state instanceof UniLabel_1.UniLabel) {
            return;
        }
        else if (state instanceof UniJump_1.UniJump) {
            return;
        }
        else if (state instanceof UniExpr_1.UniExpr) {
            return yield* this.execExpr(state, scope);
        }
        throw new RuntimeException_1.RuntimeException('Not support expr type: ' + state);
    }
    *execBlock(block, scope) {
        const blockScope = Scope_1.Scope.createLocal(scope);
        blockScope.name = scope.name;
        let ret = null;
        for (const stateOfBlock of block.body) {
            yield* this.stopByYield(ret, stateOfBlock);
            ret = yield* this.execExpr(stateOfBlock, blockScope);
            this.currentState.setCurrentExpr(stateOfBlock);
            // この中でさらにexecBlockが呼ばれた場合thisは？//Sumに代入されているかチェック
        }
        scope.removeChild(blockScope);
        return ret;
    }
    *execIf(ui, scope) {
        const cond = this.toBool(yield* this.execExpr(ui.cond, scope));
        const nextStatement = cond ? ui.trueStatement : ui.falseStatement;
        if (nextStatement) {
            if (!(nextStatement instanceof UniBlock_1.UniBlock)) {
                yield* this.stopByYield(cond, nextStatement);
            }
            return yield* this.execExpr(nextStatement, scope);
        }
    }
    *execFor(uf, scope) {
        const forScope = Scope_1.Scope.createLocal(scope);
        forScope.name = scope.name;
        if (uf.init == null) {
            uf.init = new UniEmptyStatement_1.UniEmptyStatement();
        }
        if (uf.cond == null) {
            uf.cond = new UniBoolLiteral_1.UniBoolLiteral(true);
        }
        if (uf.step == null) {
            uf.step = new UniEmptyStatement_1.UniEmptyStatement();
        }
        let ret = null;
        for (yield* this.execExpr(uf.init, forScope); this.toBool(yield* this.execExpr(uf.cond, forScope)); yield* this.stopByYield(ret, uf.cond), yield* this.execExpr(uf.step, forScope)) {
            try {
                if (!(uf.statement instanceof UniBlock_1.UniBlock)) {
                    yield* this.stopByYield(ret, uf.statement);
                }
                ret = yield* this.execExpr(uf.statement, forScope);
            }
            catch (e) {
                if (e instanceof Continue) {
                    continue;
                }
                else if (e instanceof Break) {
                    break;
                }
                else {
                    throw e;
                }
            }
        }
        scope.removeChild(forScope);
        return ret;
    }
    *execEnhancedFor(euf, scope) {
        const forScope = Scope_1.Scope.createLocal(scope);
        forScope.name = scope.name;
        let ret = null;
        let isFirst = true;
        for (const value of yield* this.execExpr(euf.container, forScope)) {
            try {
                if (!(euf.statement instanceof UniBlock_1.UniBlock)) {
                    yield* this.stopByYield(ret, euf.statement);
                }
                if (isFirst) {
                    yield* this.execVariableDec(new UniVariableDec_1.UniVariableDec([], euf.type, [new UniVariableDef_1.UniVariableDef(euf.name.name, value, null)]), forScope);
                    isFirst = false;
                }
                else {
                    const leftEvaluated = yield* this.getAddress(euf.name, forScope);
                    ret = this.execAssign(leftEvaluated, value, forScope);
                }
                ret = yield* this.execExpr(euf.statement, forScope);
            }
            catch (e) {
                if (e instanceof Continue) {
                    continue;
                }
                else if (e instanceof Break) {
                    break;
                }
                else {
                    throw e;
                }
            }
        }
        scope.removeChild(forScope);
        return ret;
    }
    *execWhile(uw, scope) {
        let ret;
        while (this.toBool(yield* this.execExpr(uw.cond, scope))) {
            try {
                if (!(uw.statement instanceof UniBlock_1.UniBlock)) {
                    yield* this.stopByYield(ret, uw.statement);
                }
                ret = yield* this.execExpr(uw.statement, scope);
            }
            catch (e) {
                if (e instanceof Continue) {
                    continue;
                }
                else if (e instanceof Break) {
                    break;
                }
                else {
                    throw e;
                }
            }
            yield* this.stopByYield(ret, uw.cond);
        }
        return ret;
    }
    *execDoWhile(udw, scope) {
        let ret;
        do {
            try {
                if (!(udw.statement instanceof UniBlock_1.UniBlock)) {
                    yield* this.stopByYield(ret, udw.statement);
                }
                ret = yield* this.execExpr(udw.statement, scope);
            }
            catch (e) {
                if (e instanceof Continue) {
                    continue;
                }
                else if (e instanceof Break) {
                    break;
                }
                else {
                    throw e;
                }
            }
            yield* this.stopByYield(ret, udw.cond);
        } while (this.toBool(yield* this.execExpr(udw.cond, scope)));
        return ret;
    }
    *execSwitch(us, scope) {
        const switchScope = Scope_1.Scope.createLocal(scope);
        switchScope.name = scope.name;
        let ret;
        let didJump = false;
        const cond = yield* this.execExpr(us.cond, scope);
        let defaultCase = null;
        while (!didJump) {
            for (const unit of us.cases) {
                if (unit.label === 'default') {
                    if (defaultCase == null) {
                        defaultCase = unit;
                        continue;
                    }
                    else {
                        didJump = true;
                    }
                }
                const condOfCase = unit.cond != null ? yield* this.execExpr(unit.cond, switchScope) : null;
                if (didJump || cond.valueOf() === condOfCase.valueOf()) {
                    yield* this.stopByYield(cond, unit.cond);
                    didJump = true;
                    try {
                        for (const statement of unit.statement) {
                            yield* this.stopByYield(ret, statement);
                            ret = yield* this.execExpr(statement, scope);
                        }
                    }
                    catch (e) {
                        if (e instanceof Break) {
                            break;
                        }
                        else {
                            throw e;
                        }
                    }
                }
            }
            if (defaultCase == null) {
                break;
            }
        }
        return ret;
    }
    *execExpr(expr, scope) {
        // firePreExec(expr, scope);
        const value = yield* this._execExpr(expr, scope);
        // firePostExec(expr, scope, value);
        return value;
    }
    *execCast(expr, scope) {
        return yield* this.execExpr(expr.value, scope);
    }
    // tslint:disable-next-line:function-name
    _execCast(type, value) {
        return value;
    }
    execCharLiteral(expr, scope) {
        return expr.value;
    }
    execStringLiteral(expr, scope) {
        return expr.value;
    }
    execIntLiteral(expr, scope) {
        return expr.value;
    }
    *execBinOp(arg, scope, left, right) {
        if (arg instanceof UniBinOp_1.UniBinOp && left === undefined && right === undefined) {
            const binOp = arg;
            return yield* this.execBinOp(binOp.operator, scope, binOp.left, binOp.right);
        }
        else if (typeof arg === 'string' && left instanceof UniExpr_1.UniExpr && right instanceof UniExpr_1.UniExpr) {
            const op = arg;
            let ret = null;
            switch (op) {
                case '=': {
                    const rightEvaluated = yield* this.execExpr(right, scope);
                    const leftEvaluated = yield* this.getAddress(left, scope);
                    ret = this.execAssign(leftEvaluated, rightEvaluated, scope);
                    yield ret;
                    return ret;
                }
                case '[]':
                case '.': {
                    ret = scope.getValue(yield* this.getAddress(new UniBinOp_1.UniBinOp(op, left, right), scope));
                    yield ret;
                    return ret;
                }
                default:
                    break;
            }
            const l = yield* this.execExpr(left, scope);
            const r = yield* this.execExpr(right, scope);
            ret = this.execBinOpImple(op, l, r);
            if (ret !== null) {
                yield ret;
                return ret;
            }
            // 複合代入演算子
            if (op.length > 1 && op.charAt(op.length - 1) === '=') {
                if (left instanceof UniIdent_1.UniIdent) {
                    const nextOp = op.substring(0, op.length - 1);
                    const value = yield* this.execBinOp(nextOp, scope, left, right);
                    return this.execAssign(yield* this.getAddress(left, scope), value, scope);
                }
            }
            throw new RuntimeException_1.RuntimeException('Unkown binary operator: ' + op);
        }
    }
    execBinOpImple(op, l, r) {
        let ret = null;
        switch (op) {
            case '==':
                ret = l === r;
                break;
            case '!=':
                ret = l !== r;
                break;
            case '<':
                ret = l < r;
                break;
            case '>':
                ret = l > r;
                break;
            case '>=':
                ret = l >= r;
                break;
            case '<=':
                ret = l <= r;
                break;
            case '+':
                ret = l + r;
                break;
            case '-':
                ret = l - r;
                break;
            case '*':
                ret = l * r;
                break;
            case '/':
                ret = l / r;
                break;
            case '%':
                ret = l % r;
                break;
            case '&&':
                ret = l && r;
                break;
            case '||':
                ret = l || r;
                break;
        }
        return ret;
    }
    execAssign(address, value, scope) {
        const type = scope.getRawType(address);
        Engine.lastSizeOf = type;
        value = this._execCast(type, value);
        scope.set(address, value);
        if (type && type.endsWith('*')) {
            const taddress = value;
            if (scope.isMallocArea(taddress)) {
                const size = scope.getMallocSize(taddress);
                const rawType = type.substring(0, type.length - 1);
                if (scope.isStructType(rawType)) {
                    scope.typeOnMemory.set(taddress, rawType);
                    scope.objectOnMemory.set(taddress, taddress + Engine.structInfoSize);
                    for (const v of scope.get(rawType).values()) {
                        scope.typeOnMemory.set(taddress + Engine.structInfoSize + v[0], v[1]); // 型名
                    }
                }
                else {
                    for (let i = 0; i < size; i += Engine.sizeof(rawType)) {
                        scope.typeOnMemory.set(taddress + i, rawType);
                    }
                }
            }
        }
        Engine.lastSizeOf = '';
        return value;
    }
    getType(expr, scope) {
        if (expr instanceof UniIdent_1.UniIdent) {
            const ui = expr;
            const type = scope.getType(ui.name);
            return type;
        }
        else if (expr instanceof UniUnaryOp_1.UniUnaryOp) {
            const uuo = expr;
            if (uuo.operator === '*') {
                return this.getType(uuo.expr, scope);
            }
        }
        else if (expr instanceof UniBinOp_1.UniBinOp) {
            const ubo = expr;
            if (ubo.operator === '[]') {
                const left = this.getType(ubo.left, scope);
                if (left != null) {
                    return left;
                }
                const right = this.getType(ubo.right, scope);
                if (right != null) {
                    return right;
                }
            }
            else if (ubo.operator === '.') {
                const left = this.getType(ubo.left, scope);
                const offsets = scope.get(left);
                const offset = offsets.get(ubo.right.name);
                return offset[1];
            }
        }
        return null;
    }
    randInt32() {
        return this.rand(32);
    }
    rand(bit) {
        const a = Math.pow(2, bit);
        const v = Math.floor(Math.random() * a);
        return v;
    }
    *execMethoodCall(mc, scope) {
        const args = [];
        for (let i = 0; mc.args !== null && i < mc.args.length; i++) {
            args.push(yield* this.execExpr(mc.args[i], scope));
        }
        this.currentScope = scope;
        let ret = null;
        if (mc.receiver != null) {
            if (mc.receiver instanceof UniArray_1.UniArray) {
                const item = mc.receiver.items;
                let rec = yield* this.execExpr(item[0], scope);
                for (let i = 1; i < item.length; ++i) {
                    if (item[i] instanceof UniIdent_1.UniIdent) {
                        rec = rec[item[i].name];
                    }
                    else {
                        rec = rec[yield* this.execExpr(item[i], scope)];
                    }
                }
                ret = yield* this.execFuncCall(rec[mc.methodName.name], args);
            }
            else {
                const receiver = yield* this.execExpr(mc.receiver, scope);
                if (typeof receiver === 'number') {
                    const v = scope.getValue(receiver);
                    ret = yield* this.execFuncCall(v[mc.methodName.name], args);
                }
                else {
                    ret = yield* this.execFuncCall(receiver[mc.methodName.name], args);
                }
            }
        }
        else {
            const func = scope.get(mc.methodName.name);
            if (func instanceof UniFunctionDec_1.UniFunctionDec) {
                ret = yield* this.execFunc(func, scope, args);
            }
            else {
                ret = yield* this.execFuncCall(func, args);
            }
        }
        this.currentScope = null;
        return ret;
    }
    // tslint:disable-next-line:function-name
    *_execExpr(expr, scope) {
        if (expr === null) {
            console.assert(expr != null);
        }
        if (expr instanceof UniStatement_1.UniStatement) {
            return yield* this.execStatement(expr, scope);
        }
        else if (expr instanceof UniDecralation_1.UniDecralation) {
            return yield* this.execDecralation(expr, scope);
        }
        else if (expr instanceof UniMethodCall_1.UniMethodCall) {
            return yield* this.execMethoodCall(expr, scope);
        }
        else if (expr instanceof UniIdent_1.UniIdent) {
            const ret = scope.get(expr.name);
            yield ret;
            return ret;
        }
        else if (expr instanceof UniBoolLiteral_1.UniBoolLiteral) {
            const ret = expr.value;
            yield ret;
            return ret;
        }
        else if (expr instanceof UniCharacterLiteral_1.UniCharacterLiteral) {
            const ret = this.execCharLiteral(expr, scope);
            yield ret;
            return ret;
        }
        else if (expr instanceof UniStringLiteral_1.UniStringLiteral) {
            const ret = this.execStringLiteral(expr, scope);
            yield ret;
            return ret;
        }
        else if (expr instanceof UniIntLiteral_1.UniIntLiteral) {
            const ret = this.execIntLiteral(expr, scope);
            yield ret;
            return ret;
        }
        else if (expr instanceof UniNumberLiteral_1.UniNumberLiteral) {
            const ret = expr.value;
            yield ret;
            return ret;
        }
        else if (expr instanceof UniUnaryOp_1.UniUnaryOp) {
            return yield* this.execUnaryOp(expr, scope);
        }
        else if (expr instanceof UniBinOp_1.UniBinOp) {
            return yield* this.execBinOp(expr, scope);
        }
        else if (expr instanceof UniTernaryOp_1.UniTernaryOp) {
            const condOp = expr;
            if (this.toBool(yield* this.execExpr(condOp.cond, scope))) {
                return yield* this.execExpr(condOp.trueExpr, scope);
            }
            else {
                return yield* this.execExpr(condOp.falseExpr, scope);
            }
        }
        else if (expr instanceof UniArray_1.UniArray) {
            return yield* this.execArray(expr, scope);
        }
        else if (expr instanceof UniCast_1.UniCast) {
            return yield* this.execCast(expr, scope);
        }
        throw new RuntimeException_1.RuntimeException('Not support expr type: ' + expr);
    }
    execClassDec(dec, scope) {
        // structのセット クラス名→[オフセット, 型名, sizeof]
        const fieldOffset = new Map();
        let structAddress = 0;
        for (const member of dec.members) {
            if (member instanceof UniVariableDec_1.UniVariableDec) {
                for (const def of member.variables) {
                    let size = 0;
                    if (scope.isStructType(member.type)) {
                        const offsets = scope.get(member.type);
                        for (const value of offsets.values()) {
                            size += value[2];
                        }
                        size += Engine.structInfoSize; // 構造体のサイズ情報格納分
                    }
                    else {
                        size = Engine.sizeof(member.type);
                    }
                    fieldOffset.set(def.name, [structAddress, member.type, size]);
                    structAddress += size;
                }
            }
            else if (member instanceof UniFunctionDec_1.UniFunctionDec) {
                if (member.modifiers.includes('static')) {
                    this.setGlobalObjects(member, scope);
                }
                else {
                    scope.setTop(member.name, member, member.returnType);
                }
            }
        }
        scope.setTop(dec.className, fieldOffset, 'CLASS');
    }
    clearStdout() {
        this.stdoutText = '';
    }
    clearStdin() {
        this.stdinText = '';
    }
    getEntryPoint(node) {
        let entry = null;
        if (node instanceof UniProgram_1.UniProgram) {
            const block = node.block;
            entry = this.getEntryPoint(block);
        }
        else if (node instanceof UniBlock_1.UniBlock) {
            for (const stateOfBlock of node.body) {
                entry = this.getEntryPoint(stateOfBlock);
                if (entry != null) {
                    break;
                }
            }
        }
        else if (node instanceof UniDecralation_1.UniDecralation) {
            const dec = node;
            if (dec instanceof UniFunctionDec_1.UniFunctionDec) {
                if ('main' === dec.name) {
                    return dec;
                }
            }
            else if (dec instanceof UniClassDec_1.UniClassDec) {
                for (const member of dec.members) {
                    if (member instanceof UniFunctionDec_1.UniFunctionDec) {
                        entry = this.getEntryPoint(member);
                        if (entry != null) {
                            break;
                        }
                    }
                }
            }
        }
        return entry;
    }
    setGlobalObjects(node, global) {
        if (node instanceof UniProgram_1.UniProgram) {
            const block = node.block;
            this.setGlobalObjects(block, global);
        }
        else if (node instanceof UniBlock_1.UniBlock) {
            for (const stateOfBlock of node.body) {
                this.setGlobalObjects(stateOfBlock, global);
            }
        }
        else if (node instanceof UniDecralation_1.UniDecralation) {
            const dec = node;
            if (dec instanceof UniFunctionDec_1.UniFunctionDec) {
                // 関数のセット
                if ('main' !== dec.name && dec.block != null) {
                    global.setTop(dec.name, dec, dec.returnType);
                }
            }
            else if (dec instanceof UniVariableDec_1.UniVariableDec) {
                // グローバル変数のセット
                // console.log('set global variable');
                if (dec.type instanceof UniClassDec_1.UniClassDec) {
                    const ucd = dec.type;
                    this.setGlobalObjects(ucd, global);
                    dec.type = ucd.className;
                }
                for (const n of this.execExpr(node, global)) {
                    // console.log(n);
                }
            }
            else if (dec instanceof UniClassDec_1.UniClassDec) {
                this.execClassDec(dec, global);
            }
            else if (dec instanceof UniImportDec_1.UniImportDec) {
                global.addImport(dec);
            }
        }
    }
    *execFunc(fdec, scope, args) {
        const funcScope = Scope_1.Scope.createLocal(scope);
        funcScope.name = funcScope.getNextName(fdec.name);
        // 実引数を仮引数に代入
        const params = fdec.params;
        if (params != null && args != null) {
            console.assert(params.length === args.length);
            for (let i = 0; i < args.length; ++i) {
                const param = params[i];
                let name = param.variables[0].name;
                let type = param.type;
                while (name.startsWith('*')) {
                    name = name.substring(1);
                    type += '*';
                }
                const value = args[i];
                funcScope.setTop(name, value, type);
            }
        }
        // ToDo再起の場合のチェック(連番など?
        // スコープも呼び出し先関数中とGLOBAL以外はスキップさせる
        let ret = null;
        try {
            yield* this.execBlock(fdec.block, funcScope);
        }
        catch (e) {
            if (e instanceof Exit && funcScope.name !== 'main') {
                throw e;
            }
            if (e instanceof Return) {
                ret = e.value;
            }
        }
        if (funcScope.name !== 'main') {
            scope.removeChild(funcScope);
        }
        return ret;
    }
    *execFuncCall(func, arg) {
        if (func == null) {
            throw new RuntimeException_1.RuntimeException('func is null');
        }
        else if (func instanceof Function) {
            // tslint:disable-next-line:ban-types
            const ret = func.apply(this, arg);
            if (ret && typeof ret.next === 'function') {
                let yieldObj = { done: false, value: null };
                while (!yieldObj.done) {
                    yieldObj = ret.next(arg);
                    yield yieldObj.value;
                }
                return yieldObj.value;
            }
            yield ret;
            return ret;
        }
        throw new Error('Not support function type: ' + func);
    }
}
exports.Engine = Engine;
Engine.structInfoSize = 4;
Engine.lastSizeOf = '';
//# sourceMappingURL=Engine.js.map