"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExecState = void 0;
const UniNode_1 = require("../../node/UniNode");
const UniVariableDec_1 = require("../../node/UniVariableDec");
const Scope_1 = require("./Scope");
const Stack_1 = require("./Stack");
const Variable_1 = require("./Variable");
class ExecState {
    constructor(global) {
        this.stacks = [];
        this.stackOffset = 0x10000;
        this.global = null;
        if (global !== undefined) {
            this.global = global;
        }
    }
    make() {
        this.stacks = [];
        return this.makeImple(this.global);
    }
    addVariable(stackName, param2, value, depth) {
        if (param2 instanceof Variable_1.Variable) {
            const variable = param2;
            for (let i = this.stacks.length - 1; 0 <= i; --i) {
                const stack = this.stacks[i];
                if (stack.name === stackName) {
                    stack.addVariable(variable);
                    break;
                }
            }
        }
        else if (param2 instanceof UniVariableDec_1.UniVariableDec && value !== undefined && depth !== undefined) {
            const decVar = param2;
            for (let i = this.stacks.length - 1; 0 <= i; --i) {
                const stack = this.stacks[i];
                if (stack.name === stackName) {
                    for (const v of decVar.variables) {
                        stack.addVariable(decVar.type, v.name, value, depth);
                    }
                    break;
                }
            }
        }
    }
    // 引数(variables)あり版も必要
    addStack(nameArg) {
        let name = nameArg;
        if (this.stacks.isEmpty()) {
            const stack = new Stack_1.Stack(name, this.stackOffset);
            this.stacks.push(stack);
        }
        else {
            const lastStack = this.stacks[this.stacks.length - 1];
            let lastAddress = lastStack.address;
            lastAddress += lastStack.getByteSize();
            if (this.hasStack(name)) {
                for (let i = 2;; ++i) {
                    const indexName = name + '.' + i;
                    if (!this.hasStack(indexName)) {
                        name = indexName;
                        break;
                    }
                }
            }
            const stack = new Stack_1.Stack(name, lastAddress);
            this.stacks.push(stack);
        }
        return name;
    }
    popStack() {
        this.stacks.pop();
    }
    // 更新
    updateVariable(stackName, varName, value) {
        for (let i = this.stacks.length - 1; 0 <= i; --i) {
            const stack = this.stacks[i];
            if (stack.name === stackName) {
                stack.updateVariable(varName, value);
                break;
            }
        }
    }
    removeVariables(stackName, depth) {
        if (stackName === 'main' && depth < 2) {
            return;
        }
        for (let i = this.stacks.length - 1; 0 <= i; --i) {
            const stack = this.stacks[i];
            if (stack.name === stackName) {
                stack.removeVariables(depth);
                break;
            }
        }
    }
    getCurrentValue() {
        return this.currentValue;
    }
    setCurrenValue(value) {
        this.currentValue = value;
    }
    getCurrentExpr() {
        return this.currentExpr;
    }
    setCurrentExpr(expr) {
        this.currentExpr = expr;
    }
    getNextExpr() {
        return this.nextExpr;
    }
    setNextExpr(expr) {
        this.nextExpr = expr;
    }
    getStacks() {
        return this.stacks;
    }
    getByteSize() {
        let sum = 0;
        for (const stack of this.stacks) {
            sum += stack.getByteSize();
        }
        return sum;
    }
    getTypedef(type) {
        return this.global.getTypedef(type);
    }
    makeImple(scope) {
        if (!this.hasStack(scope.name)) {
            this.addStack(scope.name);
            if (scope.name === 'GLOBAL') {
                for (let i = 10000; i < 20000; ++i) {
                    if (scope.typeOnMemory.has(i)) {
                        const type = scope.typeOnMemory.get(i);
                        if (type === 'FUNCTION') {
                            continue;
                        }
                        const value = scope.objectOnMemory.get(i);
                        const variable = new Variable_1.Variable(type, 'Static:' + i, value, i, scope.depth);
                        this.addVariable(scope.name, variable);
                    }
                }
                for (let i = 20000; i < 50000; ++i) {
                    if (scope.typeOnMemory.has(i)) {
                        const type = scope.typeOnMemory.get(i);
                        if (type === 'FUNCTION') {
                            continue;
                        }
                        const value = scope.objectOnMemory.get(i);
                        const variable = new Variable_1.Variable(type, 'Heap:' + i, value, i, scope.depth);
                        this.addVariable(scope.name, variable);
                    }
                }
            }
        }
        const varList = [];
        for (const key of scope.variableAddress.keys()) {
            varList.push(key);
        }
        console.log(varList);
        console.log(scope.variableAddress);
        for (const varName of varList) {
            const type = scope.variableTypes.get(varName);
            if (type === 'FUNCTION' || type === 'CLASS' || type === 'SYSTEM') {
                continue;
            }
            let address = scope.variableAddress.get(varName);
            let value = scope.objectOnMemory.get(address);
            if (value instanceof UniNode_1.UniNode) {
                continue;
            }
            if (value instanceof Function) {
                continue;
            }
            // 配列 (valueが先頭要素のaddress)
            if (0 <= type.indexOf('[') && 0 <= type.indexOf(']')) {
                const dims = scope.getArrayDims(type);
                // 初期化リストがない場合
                const sum = dims.reduce((pre, cur) => pre * cur, 1);
                let startAddr = value;
                for (let i = 1; i < dims.length; ++i) {
                    startAddr = scope.objectOnMemory.get(startAddr);
                }
                const elemSizeOf = Scope_1.Scope.sizeof(type);
                let arrayList = Array.from(new Array(sum), (v, i) => {
                    const addr = startAddr + i * elemSizeOf;
                    const val = scope.objectOnMemory.get(addr);
                    return new Variable_1.Variable(null, varName, val, addr, scope.depth);
                });
                for (const dim of dims.reverse()) {
                    arrayList = arrayList.divide(dim);
                }
                address = value;
                value = arrayList;
            }
            // 構造体
            const makeStructVariable = (structType, structAddr) => {
                const filedList = [];
                if (!scope.isStructType(structType)) {
                    return filedList;
                }
                const classKey = scope.getRawType(structType);
                if (classKey !== 'CLASS') {
                    return filedList;
                }
                // class, struct
                const members = scope.get(structType);
                for (const [fieldName, offsetAndType] of members) {
                    const offset = offsetAndType[0];
                    const fieldType = offsetAndType[1];
                    let fieldAddress = structAddr + offset;
                    let fieldValue = scope.objectOnMemory.get(fieldAddress);
                    const fieldValueAsStruct = makeStructVariable(fieldType, fieldValue);
                    if (!fieldValueAsStruct.isEmpty()) {
                        fieldAddress = fieldValue;
                        fieldValue = fieldValueAsStruct;
                    }
                    const v = new Variable_1.Variable(fieldType, fieldName, fieldValue, fieldAddress, scope.depth);
                    filedList.push(v);
                }
                return filedList;
            };
            const list = makeStructVariable(type, value);
            if (!list.isEmpty()) {
                value = list;
            }
            const variable = new Variable_1.Variable(type, varName, value, address, scope.depth);
            this.addVariable(scope.name, variable);
        }
        if (scope.children.length !== 0) {
            for (const child of scope.children) {
                this.makeImple(child);
            }
        }
        return this;
    }
    hasStack(name) {
        for (const stack of this.stacks) {
            if (stack.name === name) {
                return true;
            }
        }
        return false;
    }
}
exports.ExecState = ExecState;
//# sourceMappingURL=ExecState.js.map